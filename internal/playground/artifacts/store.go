package artifacts

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"sync"
)

// Artifact represents a piece of data generated by a run (rendered prompt, response JSON, etc.).
type Artifact struct {
	Name        string
	ContentType string
	Bytes       []byte
}

// Store abstracts persistence for artifacts.
type Store interface {
	Save(ctx context.Context, runID string, artifact Artifact) (string, error)
}

// InMemoryStore keeps artifacts in memory for fast tests.
type InMemoryStore struct {
	mu        sync.RWMutex
	artifacts map[string][]Artifact
}

// NewInMemoryStore constructs an empty in-memory store.
func NewInMemoryStore() *InMemoryStore {
	return &InMemoryStore{artifacts: make(map[string][]Artifact)}
}

// Save stores the artifact and returns its key.
func (s *InMemoryStore) Save(_ context.Context, runID string, artifact Artifact) (string, error) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.artifacts[runID] = append(s.artifacts[runID], artifact)
	return fmt.Sprintf("memory://%s/%s", runID, artifact.Name), nil
}

// FilesystemStore persists artifacts to disk.
type FilesystemStore struct {
	root string
}

// NewFilesystemStore creates a store rooted at the path.
func NewFilesystemStore(root string) *FilesystemStore {
	return &FilesystemStore{root: root}
}

// Save writes the artifact to disk.
func (s *FilesystemStore) Save(_ context.Context, runID string, artifact Artifact) (string, error) {
	if err := os.MkdirAll(filepath.Join(s.root, runID), 0o755); err != nil {
		return "", fmt.Errorf("ensure dir: %w", err)
	}
	path := filepath.Join(s.root, runID, artifact.Name)
	if err := os.WriteFile(path, artifact.Bytes, 0o644); err != nil {
		return "", fmt.Errorf("write artifact: %w", err)
	}
	return path, nil
}
