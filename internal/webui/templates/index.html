<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Singularity UI</title>
  <script src="https:/cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-900 text-gray-100 h-screen flex flex-col">
  <header class="p-4 bg-gray-800 border-b border-gray-700">
    <div class="max-w-6xl mx-auto">Singularity Web UI</div>
  </header>
  <main class="flex-1 overflow-hidden max-w-6xl mx-auto w-full flex gap-4 p-4">
    <section id="chat" class="flex-1 bg-gray-800 rounded-lg p-3 flex flex-col">
      <h2 class="text-sm text-gray-300 mb-2">Chat</h2>
      <div id="chatPane" class="flex-1 overflow-auto space-y-3 pr-2">
        <!-- messages go here -->
      </div>
    </section>
    <aside id="tools" class="w-80 bg-gray-800 rounded-lg p-3 flex flex-col">
      <h2 class="text-sm text-gray-300 mb-2">Tools</h2>
      <div id="toolsPane" class="flex-1 overflow-auto text-sm text-gray-300 break-words">
        No tool activity yet.
      </div>
    </aside>
  </main>
  <footer class="p-4 bg-gray-800 border-t border-gray-700">
    <div class="max-w-6xl mx-auto flex gap-2">
      <input id="promptInput" type="text" aria-label="Prompt" placeholder="Type your prompt..." class="flex-1 px-3 py-2 rounded bg-gray-700 focus:outline-none focus:ring-2 focus:ring-indigo-500" />
      <button id="submitBtn" class="px-4 py-2 rounded bg-indigo-600 hover:bg-indigo-500">Submit</button>
    </div>
  </footer>

  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
  <script>
// Helper: append message to chat pane (renders markdown for agent)
function appendMessage(kind, text, raw=false) {
  const chat = document.getElementById('chatPane')
  const el = document.createElement('div')
  if (kind === 'user') {
    el.className = 'text-right text-indigo-200'
    el.textContent = text
  } else if (kind === 'agent') {
    el.className = 'text-left text-gray-200 whitespace-pre-wrap'
    // Store raw markdown for streaming updates
    el.dataset.rawMarkdown = text || ''
    if (raw) el.textContent = text
    else el.innerHTML = marked.parse(text || '')
  } else if (kind === 'info') {
    el.className = 'text-center text-gray-400 italic text-sm'
    el.textContent = text
  }
  chat.appendChild(el)
  chat.scrollTop = chat.scrollHeight
}

function appendToolEvent(title, content) {
  const pane = document.getElementById('toolsPane')
  // If first time, clear default text
  if (pane.textContent.trim() === 'No tool activity yet.') pane.textContent = ''
  const wrapper = document.createElement('div')
  wrapper.className = 'mb-3'
  const h = document.createElement('div')
  h.className = 'font-semibold text-gray-200 mb-1'
  h.textContent = title
  const b = document.createElement('div')
  b.className = 'text-sm text-green-400 bg-gray-900 p-3 rounded font-mono border border-gray-600'
  b.style.cssText = 'white-space: pre-wrap; word-wrap: break-word; overflow-wrap: break-word;'
  b.textContent = content
  wrapper.appendChild(h)
  wrapper.appendChild(b)
  pane.appendChild(wrapper)
  pane.scrollTop = pane.scrollHeight
}

async function submitPrompt(prompt) {
  appendMessage('user', prompt)
  const backend = '/api/prompt'

  // Try SSE first by requesting Accept: text/event-stream
  const sseRes = await fetch(backend, {
    method: 'POST', headers: {'Content-Type':'application/json', 'Accept':'text/event-stream'},
    body: JSON.stringify({prompt})
  })

  const ct = sseRes.headers.get('content-type') || ''
  if (sseRes.status >= 400) {
    // read text error
    const txt = await sseRes.text()
    appendMessage('agent', 'Error: ' + txt, true)
    return
  }

  if (ct.includes('text/event-stream')) {
    // Stream with streaming parser
    const reader = sseRes.body.getReader()
    const dec = new TextDecoder()
    let buf = ''
    appendMessage('agent', '') // placeholder for streaming content
    while (true) {
      const { value, done } = await reader.read()
      if (done) break
      buf += dec.decode(value, {stream: true})
      // SSE parsing: events separated by double newline
      let idx
      while ((idx = buf.indexOf('\n\n')) !== -1) {
        const raw = buf.slice(0, idx).trim()
        buf = buf.slice(idx+2)
        // Each line in raw starts with "data: " optionally
        const lines = raw.split(/\r?\n/)
        lines.forEach(line=>{
          if (line.startsWith('data:')) {
            const payload = line.slice(5).trim()
            // Expect JSON payloads with {type: 'delta'|'tool'|'final', data: '...'}
            try {
              const obj = JSON.parse(payload)
              if (obj.type === 'delta') {
                // Append to last agent message
                const chat = document.getElementById('chatPane')
                const last = chat.lastElementChild
                if (last && last.dataset.rawMarkdown !== undefined) {
                  // Append to raw markdown and re-render
                  if (last.dataset.rawMarkdown === '') {
                    // First delta - trim leading whitespace
                    last.dataset.rawMarkdown = obj.data.trimStart()
                  } else {
                    last.dataset.rawMarkdown += obj.data
                  }
                  last.innerHTML = marked.parse(last.dataset.rawMarkdown)
                  chat.scrollTop = chat.scrollHeight
                }
              } else if (obj.type === 'tool') {
                appendToolEvent(obj.title || 'Tool', obj.data || '')
              } else if (obj.type === 'final') {
                // replace last element with final rendered markdown
                const chat = document.getElementById('chatPane')
                const last = chat.lastElementChild
                if (last && last.dataset.rawMarkdown !== undefined) {
                  last.dataset.rawMarkdown = obj.data || ''
                  last.innerHTML = marked.parse(last.dataset.rawMarkdown)
                }
              }
            } catch (e) {
              // Not JSON, append raw
              appendMessage('agent', payload, false)
            }
          }
        })
      }
    }
    // process any remaining buffer
    if (buf.trim() !== '') {
      try {
        const obj = JSON.parse(buf.trim())
        if (obj.type === 'final') appendMessage('agent', obj.data || '', false)
      } catch (e) {
        appendMessage('agent', buf, true)
      }
    }
    return
  }

  // Fallback: non-streaming
  const ctype = sseRes.headers.get('content-type') || ''
  if (ctype.includes('application/json')) {
    const j = await sseRes.json()
    if (j.result) appendMessage('agent', j.result, false)
    else appendMessage('agent', JSON.stringify(j), true)
  } else {
    const txt = await sseRes.text()
    appendMessage('agent', txt, true)
  }
}

document.getElementById('submitBtn').addEventListener('click', async () => {
  const input = document.getElementById('promptInput')
  const v = input.value.trim()
  if (!v) return
  input.value = ''
  try {
    await submitPrompt(v)
  } catch (err) {
    appendMessage('agent', 'Error: ' + err.message, true)
  }
})

// Press Enter to submit
document.getElementById('promptInput').addEventListener('keydown', (e)=>{
  if (e.key === 'Enter') { e.preventDefault(); document.getElementById('submitBtn').click() }
})
</script>
</body>
</html>
