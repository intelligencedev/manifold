sequenceDiagram
  participant KafkaClient as CommandProducer (Kafka)
  participant Orch as orchestrator.HandleCommandMessage
  participant WarppAdapter as orchestrator.NewWarppAdapter
  participant Warpp as warpp.Runner
  participant Tools as tools.Registry
  participant SpecTool as specialists_infer (Tool)
  participant SpecReg as specialists.Registry
  participant Agent as specialists.Agent
  participant Provider as LLM Provider (openaillm.Client)
  participant SubTool as Tool (any tool invoked by specialist)

  KafkaClient->>Orch: { correlation_id, workflow, attrs }
  Orch->>WarppAdapter: Execute(workflow, attrs, publishFn)
  WarppAdapter->>Warpp: Personalize(workflow, attrs)
  Warpp->>Warpp: renderArgs(${A.x}) -> step args (e.g. { "specialist":"orchestrator", "prompt":"${A.utter}" })
  Warpp->>Tools: Dispatch("specialists_infer", rawArgs)
  Tools->>SpecTool: Call(rawArgs)
  SpecTool->>SpecReg: Get(specialistName)
  SpecReg-->>Agent: *Agent (copy)
  SpecTool->>Agent: Inference(ctx, prompt, history)
  Agent->>Provider: ChatWithOptions(messages, tool_schemas_if_enabled, model, extra)
  alt LLM returns tool call
    Provider-->>Agent: tool call (name + args)
    Agent->>Tools: Dispatch(toolName, toolArgs)  %% provider propagated via context
    Tools->>SubTool: Call(args)
    SubTool-->>Tools: result payload
    Tools-->>Agent: payload
  end
  Agent-->>SpecTool: string output / json
  SpecTool-->>Tools: payload (ok/specialist/model/used_reasoning_effort/output)
  Tools-->>Warpp: payload (raw tool result)
  Warpp->>Orch: summary/result (via Runner.Execute -> publishFn)
  Orch->>KafkaClient: write success response (reply topic)